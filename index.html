<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Cloud Bounce DJ - Bass Fluff</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #1a0a2e; }
  canvas { display: block; width: 100%; height: 100%; touch-action: none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// ============================================================
// CLOUD BOUNCE DJ - Bass Fluff
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- Responsive sizing ---
let W, H, SCALE;
function resize() {
  W = canvas.width = window.innerWidth * devicePixelRatio;
  H = canvas.height = window.innerHeight * devicePixelRatio;
  SCALE = Math.min(W, H) / 800;
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
}
resize();
window.addEventListener('resize', resize);

// --- Constants ---
const BOUNCE_VEL = -13;
const MOVE_ACCEL = 0.6;
const MOVE_FRICTION = 0.85;
const STEM_ACTIVE_TIME = 6000;
const STEM_FADE_IN = 200;
const STEM_FADE_OUT = 2000;
const CLOUD_MIN_Y = 0.15;
const CLOUD_MAX_Y = 0.85;
const NUM_STEMS = 5;
const BPM = 130;
const BEAT_INTERVAL = 60000 / BPM;

// --- Stem definitions ---
const STEM_DEFS = [
  { file: 'stems/drums.mp3',   name: 'Drums',  color: '#FF1493', colorLight: '#FF69B4' },
  { file: 'stems/bass.mp3',    name: 'Bass',   color: '#7B2FBE', colorLight: '#A855F7' },
  { file: 'stems/vocals.mp3',  name: 'Vocals', color: '#FFF5E1', colorLight: '#FFFFFF' },
  { file: 'stems/keys.mp3',    name: 'Keys',   color: '#87CEEB', colorLight: '#B0E0E6' },
  { file: 'stems/sick.mp3',    name: 'Sick',   color: '#E0C3FC', colorLight: '#F0E6FF', rainbow: true },
];

// ============================================================
// DIFFICULTY SYSTEM
// ============================================================
// Returns all difficulty-scaled parameters based on time alive.
// Phases: Chill (0-20s) → Building (20-60s) → Full (60-120s) → Chaos (120s+)

function getDifficulty() {
  const t = timeAlive / 1000; // seconds

  // Smooth interpolation helper
  const lerp = (a, b, pct) => a + (b - a) * Math.min(1, Math.max(0, pct));

  let phase, phaseProgress;
  if (t < 20) {
    phase = 'chill';
    phaseProgress = t / 20;
  } else if (t < 60) {
    phase = 'building';
    phaseProgress = (t - 20) / 40;
  } else if (t < 120) {
    phase = 'full';
    phaseProgress = (t - 60) / 60;
  } else {
    phase = 'chaos';
    phaseProgress = Math.min(1, (t - 120) / 120); // caps at 240s
  }

  // Gravity: starts floaty, ramps up
  let gravity;
  if (t < 20)       gravity = lerp(0.28, 0.35, phaseProgress);
  else if (t < 60)  gravity = lerp(0.35, 0.45, phaseProgress);
  else if (t < 120) gravity = lerp(0.45, 0.52, phaseProgress);
  else              gravity = lerp(0.52, 0.62, phaseProgress);

  // Cloud size multiplier: big → small
  let cloudScale;
  if (t < 20)       cloudScale = lerp(1.4, 1.2, phaseProgress);
  else if (t < 60)  cloudScale = lerp(1.2, 1.0, phaseProgress);
  else if (t < 120) cloudScale = lerp(1.0, 0.85, phaseProgress);
  else              cloudScale = lerp(0.85, 0.65, phaseProgress);

  // Cloud drift speed multiplier
  let driftSpeed;
  if (t < 20)       driftSpeed = lerp(0.7, 0.85, phaseProgress);
  else if (t < 60)  driftSpeed = lerp(0.85, 1.1, phaseProgress);
  else if (t < 120) driftSpeed = lerp(1.1, 1.4, phaseProgress);
  else              driftSpeed = lerp(1.4, 1.9, phaseProgress);

  // Minimum clouds on screen
  let minClouds;
  if (t < 20)       minClouds = 7;
  else if (t < 60)  minClouds = 6;
  else if (t < 120) minClouds = 5;
  else              minClouds = Math.max(3, 5 - Math.floor(phaseProgress * 2));

  // Spawn rate (ms between spawns) - slower over time = fewer clouds
  let spawnRate;
  if (t < 20)       spawnRate = lerp(1400, 1600, phaseProgress);
  else if (t < 60)  spawnRate = lerp(1600, 2000, phaseProgress);
  else if (t < 120) spawnRate = lerp(2000, 2500, phaseProgress);
  else              spawnRate = lerp(2500, 3200, phaseProgress);

  // Drop moments (gravity spikes) - only after 60s
  let dropMultiplier = 1;
  if (t > 60) {
    const dropPhase = Math.sin(t * 0.12);
    if (dropPhase > 0.7) {
      const dropIntensity = t < 120 ? 1.3 : 1.6;
      dropMultiplier = dropIntensity;
    }
  }

  return { phase, gravity, cloudScale, driftSpeed, minClouds, spawnRate, dropMultiplier };
}

// --- Game State ---
let gameState = 'title';
let audioCtx = null;
let masterFilter = null;
let stems = [];
let stemGains = [];
let stemVolumes = [];
let stemTimers = [];
let stemDuration = 0;
let audioStartTime = 0;
let score = 0;
let timeAlive = 0;
let comboTypes = new Set();
let comboMultiplier = 1;
let highScore = parseInt(localStorage.getItem('cloudbounce_high') || '0');
let countdownTimer = 0;
let countdownNum = 3;

// --- Screen shake ---
let shakeX = 0, shakeY = 0, shakeIntensity = 0;

// --- Floating text ---
let floatingTexts = [];

// --- Stem name flashes ---
let stemFlashes = []; // {name, color, life, x, y}

// --- Ripples ---
let ripples = []; // {x, y, radius, maxRadius, life, color}

// --- Background clouds (parallax) ---
let bgClouds = [];
for (let i = 0; i < 12; i++) {
  bgClouds.push({
    x: Math.random(),
    y: 0.05 + Math.random() * 0.6,
    size: 0.3 + Math.random() * 0.7,
    speed: 0.002 + Math.random() * 0.005,
    alpha: 0.06 + Math.random() * 0.08,
  });
}

// --- Player ---
let player = { x: 0, y: 0, vx: 0, vy: 0, facing: 1, bounceAnim: 0, hairPhase: 0 };

// --- Trail ---
let trail = [];

// --- Clouds ---
let clouds = [];
let cloudSpawnTimer = 0;

// --- Particles ---
let particles = [];
const MAX_PARTICLES = 300;

// --- Input ---
let keys = {};
let touchLeft = false, touchRight = false;

// --- Loading ---
let loadProgress = 0;
let loadTotal = NUM_STEMS;

// --- Beat tracking ---
function getBeatPhase() {
  if (!audioCtx || !audioStartTime) return (Date.now() % BEAT_INTERVAL) / BEAT_INTERVAL;
  const elapsed = (audioCtx.currentTime - audioStartTime) * 1000;
  return (elapsed % BEAT_INTERVAL) / BEAT_INTERVAL;
}

function getBeatPulse() {
  const phase = getBeatPhase();
  return Math.max(0, 1 - phase * 2.5);
}

// ============================================================
// AUDIO SYSTEM
// ============================================================

async function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // iOS/mobile requires explicit resume on user gesture
  if (audioCtx.state === 'suspended') {
    await audioCtx.resume();
  }

  masterFilter = audioCtx.createBiquadFilter();
  masterFilter.type = 'lowpass';
  masterFilter.frequency.value = 800;
  masterFilter.Q.value = 0.7;
  masterFilter.connect(audioCtx.destination);

  stems = [];
  stemGains = [];
  stemVolumes = new Array(NUM_STEMS).fill(0);
  stemTimers = new Array(NUM_STEMS).fill(0);

  const buffers = await Promise.all(STEM_DEFS.map(async (def, i) => {
    const resp = await fetch(def.file);
    const arrayBuf = await resp.arrayBuffer();
    loadProgress = i + 1;
    return await audioCtx.decodeAudioData(arrayBuf);
  }));

  stemDuration = buffers[0].duration;

  buffers.forEach((buf, i) => {
    const source = audioCtx.createBufferSource();
    source.buffer = buf;
    source.loop = true;
    const gain = audioCtx.createGain();
    gain.gain.value = 0;
    source.connect(gain);
    gain.connect(masterFilter);
    source.start(0);
    stems.push(source);
    stemGains.push(gain);
  });

  audioStartTime = audioCtx.currentTime;

  // Handle audio context interruptions (tab switch, phone call, etc.)
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden && audioCtx && audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  });
}

function activateStem(index) {
  stemTimers[index] = STEM_ACTIVE_TIME;
}

function updateStemVolumes(dt) {
  let activeCount = 0;
  for (let i = 0; i < NUM_STEMS; i++) {
    if (stemTimers[i] > 0) {
      stemTimers[i] -= dt;
      stemVolumes[i] = Math.min(1, stemVolumes[i] + dt / STEM_FADE_IN);
    } else {
      stemVolumes[i] = Math.max(0, stemVolumes[i] - dt / STEM_FADE_OUT);
    }
    if (stemGains[i]) stemGains[i].gain.value = stemVolumes[i];
    if (stemVolumes[i] > 0.1) activeCount++;
  }

  if (masterFilter) {
    const ratio = activeCount / NUM_STEMS;
    const targetFreq = 800 + ratio * ratio * 19200;
    const currentFreq = masterFilter.frequency.value;
    masterFilter.frequency.value = currentFreq + (targetFreq - currentFreq) * 0.05;
  }
}

// ============================================================
// CLOUD SPAWNING
// ============================================================

function spawnCloud(forceY) {
  const diff = getDifficulty();
  const stemIndex = Math.floor(Math.random() * NUM_STEMS);
  const fromLeft = Math.random() < 0.5;
  const baseW = (80 + Math.random() * 50) * diff.cloudScale;
  const baseH = (35 + Math.random() * 15) * diff.cloudScale;
  const w = baseW * SCALE;
  const h = baseH * SCALE;
  const speed = (0.5 + Math.random() * 1.0) * diff.driftSpeed * SCALE;
  const y = forceY !== undefined ? forceY : (CLOUD_MIN_Y + Math.random() * (CLOUD_MAX_Y - CLOUD_MIN_Y)) * H;

  clouds.push({
    x: fromLeft ? -w : W + w,
    y, w, h,
    vx: fromLeft ? speed : -speed,
    stemIndex,
    glow: 0,
    pulsePhase: Math.random() * Math.PI * 2,
  });
}

function ensureReachableClouds() {
  const diff = getDifficulty();
  const onScreen = clouds.filter(c => c.x > -c.w && c.x < W + c.w);
  while (onScreen.length < diff.minClouds) {
    const y = (CLOUD_MIN_Y + Math.random() * (CLOUD_MAX_Y - CLOUD_MIN_Y)) * H;
    const x = Math.random() * W * 0.8 + W * 0.1;
    const stemIndex = Math.floor(Math.random() * NUM_STEMS);
    const baseW = (80 + Math.random() * 50) * diff.cloudScale;
    const baseH = (35 + Math.random() * 15) * diff.cloudScale;
    const w = baseW * SCALE;
    const h = baseH * SCALE;
    const speed = (0.5 + Math.random() * 1.0) * diff.driftSpeed * SCALE;
    const dir = Math.random() < 0.5 ? 1 : -1;
    const cloud = { x, y, w, h, vx: speed * dir, stemIndex, glow: 0, pulsePhase: Math.random() * Math.PI * 2 };
    clouds.push(cloud);
    onScreen.push(cloud);
  }
}

// ============================================================
// PARTICLES & EFFECTS
// ============================================================

function spawnBounceParticles(x, y, color) {
  for (let i = 0; i < 15; i++) {
    if (particles.length >= MAX_PARTICLES) particles.shift();
    const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI * 1.2;
    const speed = (2 + Math.random() * 5) * SCALE;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      decay: 0.01 + Math.random() * 0.02,
      size: (3 + Math.random() * 6) * SCALE,
      color,
      type: 'fluff',
    });
  }
  for (let i = 0; i < 8; i++) {
    if (particles.length >= MAX_PARTICLES) particles.shift();
    particles.push({
      x: x + (Math.random() - 0.5) * 50 * SCALE,
      y: y - Math.random() * 20 * SCALE,
      vx: (Math.random() - 0.5) * 2.5 * SCALE,
      vy: -1.5 * SCALE - Math.random() * 3 * SCALE,
      life: 1,
      decay: 0.012 + Math.random() * 0.01,
      size: (1.5 + Math.random() * 3) * SCALE,
      color: '#FFFFFF',
      type: 'sparkle',
    });
  }
}

function spawnRipple(x, y, color) {
  ripples.push({ x, y, radius: 0, maxRadius: 80 * SCALE, life: 1, color });
}

function spawnStemFlash(name, color, x, y) {
  stemFlashes.push({ name, color, life: 1, x, y: y - 50 * SCALE });
}

function spawnFloatingText(x, y, text, color) {
  floatingTexts.push({ x, y, text, color, life: 1, vy: -2 * SCALE });
}

function updateEffects(dt) {
  // Particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.05 * SCALE;
    p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }
  // Floating texts
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const ft = floatingTexts[i];
    ft.y += ft.vy;
    ft.life -= 0.015;
    if (ft.life <= 0) floatingTexts.splice(i, 1);
  }
  // Stem flashes
  for (let i = stemFlashes.length - 1; i >= 0; i--) {
    const sf = stemFlashes[i];
    sf.life -= 0.025;
    sf.y -= 1.5 * SCALE;
    if (sf.life <= 0) stemFlashes.splice(i, 1);
  }
  // Ripples
  for (let i = ripples.length - 1; i >= 0; i--) {
    const r = ripples[i];
    r.radius += 3 * SCALE;
    r.life -= 0.03;
    if (r.life <= 0 || r.radius > r.maxRadius) ripples.splice(i, 1);
  }
}

function drawEffects() {
  // Ripples
  ripples.forEach(r => {
    ctx.strokeStyle = r.color;
    ctx.lineWidth = 2 * SCALE * r.life;
    ctx.globalAlpha = r.life * 0.6;
    ctx.beginPath();
    ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;
  });

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life * 0.8;
    if (p.type === 'sparkle') {
      ctx.fillStyle = '#FFFFFF';
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 8 * SCALE;
      const s = p.size * p.life;
      ctx.beginPath(); ctx.arc(p.x, p.y, s, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = '#FFFFFF';
      ctx.lineWidth = 1 * SCALE;
      ctx.beginPath();
      ctx.moveTo(p.x - s * 2, p.y); ctx.lineTo(p.x + s * 2, p.y);
      ctx.moveTo(p.x, p.y - s * 2); ctx.lineTo(p.x, p.y + s * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    } else {
      ctx.fillStyle = p.color;
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 6 * SCALE;
      ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2); ctx.fill();
      ctx.shadowBlur = 0;
    }
    ctx.globalAlpha = 1;
  });

  // Floating texts
  floatingTexts.forEach(ft => {
    ctx.globalAlpha = ft.life;
    ctx.fillStyle = ft.color;
    ctx.font = `bold ${18 * SCALE}px Arial, sans-serif`;
    ctx.textAlign = 'center';
    ctx.shadowColor = ft.color;
    ctx.shadowBlur = 10 * SCALE;
    ctx.fillText(ft.text, ft.x, ft.y);
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  });

  // Stem name flashes
  stemFlashes.forEach(sf => {
    const size = 28 + (1 - sf.life) * 8; // grows slightly
    ctx.globalAlpha = sf.life * 0.9;
    ctx.fillStyle = sf.color;
    ctx.font = `bold ${size * SCALE}px Arial, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = sf.color;
    ctx.shadowBlur = 20 * SCALE;
    ctx.fillText(sf.name.toUpperCase(), sf.x, sf.y);
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  });
}

// ============================================================
// DRAW CHARACTER
// ============================================================

function drawCharacter(x, y, isTitle) {
  const s = SCALE;
  const bounce = player.bounceAnim;
  const squish = bounce > 0 ? 1 + bounce * 0.15 : 1;
  const stretch = bounce > 0 ? 1 - bounce * 0.1 : 1;

  ctx.save();
  ctx.translate(x, y);
  ctx.scale(player.facing, 1);
  ctx.scale(squish, stretch);

  // Platform boots
  ctx.fillStyle = '#FFFFFF';
  ctx.strokeStyle = '#E0E0E0';
  ctx.lineWidth = 1.5 * s;
  ctx.beginPath(); ctx.roundRect(-14 * s, 12 * s, 12 * s, 14 * s, 3 * s); ctx.fill(); ctx.stroke();
  ctx.fillStyle = '#F0F0F0';
  ctx.fillRect(-15 * s, 22 * s, 14 * s, 5 * s); ctx.strokeRect(-15 * s, 22 * s, 14 * s, 5 * s);
  ctx.fillStyle = '#FAFAFA';
  for (let bx = -14; bx < -2; bx += 3) { ctx.beginPath(); ctx.arc(bx * s, 13 * s, 3 * s, 0, Math.PI * 2); ctx.fill(); }
  ctx.fillStyle = '#FFFFFF';
  ctx.beginPath(); ctx.roundRect(2 * s, 12 * s, 12 * s, 14 * s, 3 * s); ctx.fill(); ctx.stroke();
  ctx.fillStyle = '#F0F0F0';
  ctx.fillRect(1 * s, 22 * s, 14 * s, 5 * s); ctx.strokeRect(1 * s, 22 * s, 14 * s, 5 * s);
  ctx.fillStyle = '#FAFAFA';
  for (let bx = 3; bx < 14; bx += 3) { ctx.beginPath(); ctx.arc(bx * s, 13 * s, 3 * s, 0, Math.PI * 2); ctx.fill(); }

  // Legs
  ctx.fillStyle = '#FFDAB9';
  ctx.fillRect(-8 * s, 2 * s, 6 * s, 12 * s);
  ctx.fillRect(2 * s, 2 * s, 6 * s, 12 * s);

  // White shorts
  ctx.fillStyle = '#FFFFFF'; ctx.strokeStyle = '#E0E0E0'; ctx.lineWidth = 1 * s;
  ctx.beginPath(); ctx.roundRect(-12 * s, -4 * s, 24 * s, 10 * s, 2 * s); ctx.fill(); ctx.stroke();

  // Quilted jacket
  ctx.fillStyle = '#F5F5F5'; ctx.strokeStyle = '#E0E0E0'; ctx.lineWidth = 1 * s;
  ctx.beginPath(); ctx.roundRect(-14 * s, -28 * s, 28 * s, 28 * s, 4 * s); ctx.fill(); ctx.stroke();
  ctx.strokeStyle = '#E8E8E8'; ctx.lineWidth = 0.7 * s;
  for (let row = 0; row < 4; row++) {
    for (let col = 0; col < 3; col++) {
      const cx = (-10 + col * 9) * s, cy = (-24 + row * 7) * s;
      ctx.beginPath(); ctx.moveTo(cx, cy - 3 * s); ctx.lineTo(cx + 4 * s, cy);
      ctx.lineTo(cx, cy + 3 * s); ctx.lineTo(cx - 4 * s, cy); ctx.closePath(); ctx.stroke();
    }
  }
  // Collar
  ctx.fillStyle = '#FFFFFF';
  for (let i = -12; i <= 12; i += 4) { ctx.beginPath(); ctx.arc(i * s, -28 * s, 4 * s, 0, Math.PI * 2); ctx.fill(); }
  // Zipper
  ctx.strokeStyle = '#D0D0D0'; ctx.lineWidth = 1.5 * s;
  ctx.beginPath(); ctx.moveTo(0, -28 * s); ctx.lineTo(0, -2 * s); ctx.stroke();

  // Arms
  ctx.fillStyle = '#F5F5F5'; ctx.strokeStyle = '#E0E0E0'; ctx.lineWidth = 1 * s;
  ctx.beginPath(); ctx.roundRect(-20 * s, -26 * s, 8 * s, 22 * s, 3 * s); ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.roundRect(12 * s, -26 * s, 8 * s, 22 * s, 3 * s); ctx.fill(); ctx.stroke();
  // Hands
  ctx.fillStyle = '#FFDAB9';
  ctx.beginPath(); ctx.arc(-16 * s, -4 * s, 3.5 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(16 * s, -4 * s, 3.5 * s, 0, Math.PI * 2); ctx.fill();

  // Head
  ctx.fillStyle = '#FFDAB9';
  ctx.beginPath(); ctx.arc(0, -38 * s, 11 * s, 0, Math.PI * 2); ctx.fill();

  // Hair
  if (!isTitle) player.hairPhase += (player.vy > 0 ? 0.08 : 0.03);
  const hairWave = Math.sin(player.hairPhase) * 2;
  ctx.fillStyle = '#E8913A';
  ctx.beginPath(); ctx.arc(0, -42 * s, 12 * s, Math.PI, 0); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(-12 * s, -40 * s);
  ctx.quadraticCurveTo(-14 * s + hairWave * s, -25 * s, -11 * s + hairWave * s, -15 * s);
  ctx.lineTo(-8 * s, -15 * s); ctx.quadraticCurveTo(-10 * s, -25 * s, -10 * s, -38 * s); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(12 * s, -40 * s);
  ctx.quadraticCurveTo(14 * s - hairWave * s, -25 * s, 11 * s - hairWave * s, -15 * s);
  ctx.lineTo(8 * s, -15 * s); ctx.quadraticCurveTo(10 * s, -25 * s, 10 * s, -38 * s); ctx.fill();
  ctx.fillStyle = '#D4802E'; ctx.beginPath();
  ctx.moveTo(-8 * s, -45 * s); ctx.quadraticCurveTo(-2 * s, -37 * s, 5 * s, -44 * s);
  ctx.quadraticCurveTo(8 * s, -36 * s, 10 * s, -42 * s);
  ctx.quadraticCurveTo(4 * s, -50 * s, -8 * s, -48 * s); ctx.fill();

  // Eyes
  ctx.fillStyle = '#2C1810';
  ctx.beginPath(); ctx.ellipse(-4 * s, -39 * s, 1.8 * s, 2.2 * s, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(4 * s, -39 * s, 1.8 * s, 2.2 * s, 0, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#FFFFFF';
  ctx.beginPath(); ctx.arc(-3 * s, -40 * s, 0.8 * s, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.arc(5 * s, -40 * s, 0.8 * s, 0, Math.PI * 2); ctx.fill();

  // Mouth
  ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 1 * s;
  ctx.beginPath(); ctx.arc(0, -35 * s, 3 * s, 0.1, Math.PI - 0.1); ctx.stroke();

  // Blush
  ctx.fillStyle = 'rgba(255, 150, 150, 0.3)';
  ctx.beginPath(); ctx.ellipse(-7 * s, -36 * s, 3 * s, 1.8 * s, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(7 * s, -36 * s, 3 * s, 1.8 * s, 0, 0, Math.PI * 2); ctx.fill();

  // Fluffy earmuff headphones
  ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 3 * s;
  ctx.beginPath(); ctx.arc(0, -44 * s, 15 * s, Math.PI + 0.3, -0.3); ctx.stroke();
  const lx = -15 * s, ly = -38 * s;
  ctx.fillStyle = '#FFFFFF'; ctx.shadowColor = 'rgba(255,255,255,0.5)'; ctx.shadowBlur = 8 * s;
  for (let a = 0; a < Math.PI * 2; a += 0.7) { ctx.beginPath(); ctx.arc(lx + Math.cos(a) * 4 * s, ly + Math.sin(a) * 4 * s, 5 * s, 0, Math.PI * 2); ctx.fill(); }
  ctx.beginPath(); ctx.arc(lx, ly, 6 * s, 0, Math.PI * 2); ctx.fill();
  const rx = 15 * s, ry = -38 * s;
  for (let a = 0; a < Math.PI * 2; a += 0.7) { ctx.beginPath(); ctx.arc(rx + Math.cos(a) * 4 * s, ry + Math.sin(a) * 4 * s, 5 * s, 0, Math.PI * 2); ctx.fill(); }
  ctx.beginPath(); ctx.arc(rx, ry, 6 * s, 0, Math.PI * 2); ctx.fill();
  ctx.shadowBlur = 0;

  ctx.restore();
}

// ============================================================
// DRAW CLOUD
// ============================================================

function drawCloud(cloud) {
  const def = STEM_DEFS[cloud.stemIndex];
  const { x, y, w, h, glow } = cloud;
  const isActive = stemVolumes[cloud.stemIndex] > 0.1;
  const beatPulse = getBeatPulse();
  const pulse = isActive ? 1 + beatPulse * 0.08 : 1;

  ctx.save();
  ctx.translate(x, y);
  ctx.scale(pulse, pulse);

  if (glow > 0 || isActive) {
    const glowAmount = Math.max(glow, isActive ? 0.3 + beatPulse * 0.3 : 0);
    ctx.shadowColor = def.color;
    ctx.shadowBlur = (15 + glowAmount * 25) * SCALE;
  }

  let fillColor = def.color;
  if (def.rainbow) {
    const hue = (Date.now() * 0.1 + x) % 360;
    fillColor = `hsl(${hue}, 80%, 80%)`;
  }

  ctx.fillStyle = fillColor;
  ctx.globalAlpha = 0.6 + (isActive ? 0.3 + beatPulse * 0.1 : 0);
  ctx.beginPath(); ctx.ellipse(0, 0, w * 0.5, h * 0.5, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(-w * 0.28, -h * 0.15, w * 0.3, h * 0.4, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(w * 0.25, -h * 0.1, w * 0.32, h * 0.42, 0, 0, Math.PI * 2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(w * 0.05, -h * 0.35, w * 0.25, h * 0.35, 0, 0, Math.PI * 2); ctx.fill();

  ctx.fillStyle = def.colorLight;
  ctx.globalAlpha = 0.2 + (isActive ? 0.2 + beatPulse * 0.15 : 0);
  ctx.beginPath(); ctx.ellipse(0, -h * 0.1, w * 0.3, h * 0.25, 0, 0, Math.PI * 2); ctx.fill();

  ctx.globalAlpha = 0.7;
  ctx.fillStyle = '#FFFFFF';
  ctx.font = `bold ${10 * SCALE}px Arial, sans-serif`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(def.name, 0, h * 0.1);

  ctx.globalAlpha = 1; ctx.shadowBlur = 0;
  ctx.restore();
}

// ============================================================
// DRAW BACKGROUND
// ============================================================

function drawBackground() {
  const grad = ctx.createLinearGradient(0, H, 0, 0);
  grad.addColorStop(0, '#FFB5A7');
  grad.addColorStop(0.3, '#E8A0BF');
  grad.addColorStop(0.6, '#957FEF');
  grad.addColorStop(1, '#1a0a2e');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Parallax background clouds
  bgClouds.forEach(bc => {
    bc.x += bc.speed * 0.016;
    if (bc.x > 1.3) bc.x = -0.3;
    const cx = bc.x * W, cy = bc.y * H, sz = bc.size * 60 * SCALE;
    ctx.fillStyle = `rgba(255,255,255,${bc.alpha})`;
    ctx.beginPath(); ctx.ellipse(cx, cy, sz, sz * 0.4, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(cx - sz * 0.5, cy - sz * 0.1, sz * 0.6, sz * 0.35, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(cx + sz * 0.4, cy - sz * 0.05, sz * 0.55, sz * 0.38, 0, 0, Math.PI * 2); ctx.fill();
  });

  // Stars
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  const t = Date.now() * 0.001;
  const seed = 42;
  for (let i = 0; i < 60; i++) {
    const sx = ((seed * (i + 1) * 7919) % W);
    const sy = ((seed * (i + 1) * 104729) % (H * 0.5));
    const ss = ((i * 31337) % 3) + 0.5;
    const twinkle = Math.sin(t * 3 + i) * 0.3 + 0.7;
    ctx.globalAlpha = twinkle * 0.6;
    ctx.beginPath(); ctx.arc(sx, sy, ss * SCALE, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// ============================================================
// DRAW HUD
// ============================================================

function drawHUD() {
  const s = SCALE;
  const padding = 15 * s;

  ctx.fillStyle = '#FFFFFF';
  ctx.font = `bold ${20 * s}px Arial, sans-serif`;
  ctx.textAlign = 'left'; ctx.textBaseline = 'top';
  ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 4 * s;
  ctx.fillText(`Score: ${Math.floor(score)}`, padding, padding);

  if (comboMultiplier > 1) {
    ctx.fillStyle = '#FFD700';
    ctx.font = `bold ${16 * s}px Arial, sans-serif`;
    ctx.fillText(`${comboMultiplier.toFixed(1)}x COMBO`, padding, padding + 24 * s);
  }

  // Phase indicator
  const diff = getDifficulty();
  const phaseColors = { chill: '#87CEEB', building: '#FFD700', full: '#FF69B4', chaos: '#FF4444' };
  ctx.fillStyle = phaseColors[diff.phase] || '#FFFFFF';
  ctx.font = `bold ${10 * s}px Arial, sans-serif`;
  ctx.globalAlpha = 0.6;
  ctx.fillText(diff.phase.toUpperCase(), padding, padding + 44 * s);
  ctx.globalAlpha = 1;

  // Stem indicators
  const indicatorSize = 12 * s;
  const indicatorGap = 4 * s;
  const totalWidth = NUM_STEMS * (indicatorSize + indicatorGap) - indicatorGap;
  const startX = (W - totalWidth) / 2;
  const iy = padding;
  const bp = getBeatPulse();

  for (let i = 0; i < NUM_STEMS; i++) {
    const ix = startX + i * (indicatorSize + indicatorGap);
    const vol = stemVolumes[i];
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath(); ctx.arc(ix + indicatorSize / 2, iy + indicatorSize / 2, indicatorSize / 2, 0, Math.PI * 2); ctx.fill();
    if (vol > 0) {
      const pulseSize = vol > 0.5 ? bp * 2 * s : 0;
      ctx.fillStyle = STEM_DEFS[i].color;
      ctx.globalAlpha = vol;
      ctx.shadowColor = STEM_DEFS[i].color;
      ctx.shadowBlur = (6 + bp * 6) * s;
      ctx.beginPath(); ctx.arc(ix + indicatorSize / 2, iy + indicatorSize / 2, indicatorSize / 2 + pulseSize, 0, Math.PI * 2); ctx.fill();
      ctx.shadowBlur = 0; ctx.globalAlpha = 1;
    }
  }

  // Time
  ctx.fillStyle = '#FFFFFF';
  ctx.font = `bold ${14 * s}px Arial, sans-serif`;
  ctx.textAlign = 'right';
  const mins = Math.floor(timeAlive / 60000);
  const secs = Math.floor((timeAlive % 60000) / 1000);
  ctx.fillText(`${mins}:${secs.toString().padStart(2, '0')}`, W - padding, padding);

  // Song progress bar
  if (stemDuration > 0 && audioCtx) {
    const elapsed = (audioCtx.currentTime - audioStartTime) % stemDuration;
    const progress = elapsed / stemDuration;
    const barW = 120 * s, barH = 4 * s;
    const barX = W - padding - barW, barY = padding + 20 * s;
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.beginPath(); ctx.roundRect(barX, barY, barW, barH, 2 * s); ctx.fill();
    const barGrad = ctx.createLinearGradient(barX, 0, barX + barW, 0);
    barGrad.addColorStop(0, '#FF69B4'); barGrad.addColorStop(1, '#A855F7');
    ctx.fillStyle = barGrad;
    ctx.beginPath(); ctx.roundRect(barX, barY, barW * progress, barH, 2 * s); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = `${9 * s}px Arial, sans-serif`; ctx.textAlign = 'right';
    const songMins = Math.floor(elapsed / 60), songSecs = Math.floor(elapsed % 60);
    const totalMins = Math.floor(stemDuration / 60), totalSecs = Math.floor(stemDuration % 60);
    ctx.fillText(`${songMins}:${songSecs.toString().padStart(2, '0')} / ${totalMins}:${totalSecs.toString().padStart(2, '0')}`, W - padding, barY + barH + 4 * s);
  }

  ctx.shadowBlur = 0;
}

// ============================================================
// TITLE SCREEN
// ============================================================

function drawTitleScreen() {
  drawBackground();
  const s = SCALE, cx = W / 2, cy = H / 2, t = Date.now() * 0.001;

  for (let i = 0; i < 5; i++) {
    const cx2 = W * (0.15 + i * 0.18) + Math.sin(t + i) * 30 * s;
    const cy2 = H * (0.3 + Math.sin(t * 0.5 + i * 1.5) * 0.1);
    ctx.fillStyle = STEM_DEFS[i].color; ctx.globalAlpha = 0.3;
    ctx.beginPath(); ctx.ellipse(cx2, cy2, 50 * s, 22 * s, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(cx2 - 25 * s, cy2 - 8 * s, 30 * s, 18 * s, 0, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(cx2 + 20 * s, cy2 - 5 * s, 35 * s, 20 * s, 0, 0, Math.PI * 2); ctx.fill();
    ctx.globalAlpha = 1;
  }

  const floatY = cy + 40 * s + Math.sin(t * 1.5) * 15 * s;
  player.vy = Math.sin(t * 1.5) * 2; player.facing = 1;
  drawCharacter(cx, floatY, true);

  ctx.fillStyle = '#FFFFFF'; ctx.font = `bold ${18 * s}px Arial, sans-serif`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.letterSpacing = `${6 * s}px`;
  ctx.shadowColor = 'rgba(255,255,255,0.6)'; ctx.shadowBlur = 15 * s;
  ctx.fillText('BASS FLUFF', cx, cy - 80 * s); ctx.shadowBlur = 0;

  ctx.font = `bold ${36 * s}px Arial, sans-serif`; ctx.fillStyle = '#FFFFFF';
  ctx.shadowColor = 'rgba(200,100,255,0.8)'; ctx.shadowBlur = 20 * s;
  ctx.fillText('Cloud Bounce DJ', cx, cy - 45 * s); ctx.shadowBlur = 0;

  const blink = Math.sin(t * 3) * 0.3 + 0.7;
  ctx.globalAlpha = blink; ctx.fillStyle = '#FFD700'; ctx.font = `bold ${16 * s}px Arial, sans-serif`;
  ctx.fillText('Click or Tap to Start', cx, cy + 120 * s); ctx.globalAlpha = 1;

  if (highScore > 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.font = `${12 * s}px Arial, sans-serif`;
    ctx.fillText(`High Score: ${highScore}`, cx, cy + 150 * s);
  }
  ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.font = `${11 * s}px Arial, sans-serif`;
  ctx.fillText('Arrow Keys / A,D / Touch to Move', cx, H - 30 * s);
}

// ============================================================
// LOADING / COUNTDOWN / GAME OVER SCREENS
// ============================================================

function drawLoading() {
  drawBackground();
  const s = SCALE, cx = W / 2, cy = H / 2;
  ctx.fillStyle = '#FFFFFF'; ctx.font = `bold ${20 * s}px Arial, sans-serif`; ctx.textAlign = 'center';
  ctx.fillText('Loading Stems...', cx, cy - 20 * s);
  const barW = 200 * s, barH = 10 * s;
  ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fillRect(cx - barW / 2, cy + 10 * s, barW, barH);
  ctx.fillStyle = '#FF69B4'; ctx.fillRect(cx - barW / 2, cy + 10 * s, barW * (loadProgress / loadTotal), barH);
  ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font = `${12 * s}px Arial, sans-serif`;
  ctx.fillText(`${loadProgress} / ${loadTotal}`, cx, cy + 40 * s);
}

function drawCountdown() {
  drawBackground();
  const s = SCALE, cx = W / 2, cy = H / 2;
  clouds.forEach(c => drawCloud(c));
  drawCharacter(player.x, player.y);
  ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillRect(0, 0, W, H);
  const progress = countdownTimer / 1000;
  const scale = 1 + (1 - progress) * 0.5;
  const alpha = progress < 0.2 ? progress / 0.2 : 1;
  ctx.save(); ctx.translate(cx, cy); ctx.scale(scale, scale);
  ctx.globalAlpha = alpha; ctx.fillStyle = '#FFFFFF';
  ctx.font = `bold ${72 * s}px Arial, sans-serif`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.shadowColor = 'rgba(200,100,255,0.8)'; ctx.shadowBlur = 30 * s;
  ctx.fillText(countdownNum <= 0 ? 'GO!' : countdownNum.toString(), 0, 0);
  ctx.shadowBlur = 0; ctx.globalAlpha = 1; ctx.restore();
}

function drawGameOver() {
  const s = SCALE, cx = W / 2, cy = H / 2;
  ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, W, H);
  ctx.textAlign = 'center';
  ctx.fillStyle = '#FFFFFF'; ctx.shadowColor = 'rgba(200,100,255,0.8)'; ctx.shadowBlur = 20 * s;
  ctx.font = `bold ${36 * s}px Arial, sans-serif`;
  ctx.fillText('Game Over', cx, cy - 70 * s); ctx.shadowBlur = 0;
  ctx.font = `bold ${24 * s}px Arial, sans-serif`;
  ctx.fillText(`Score: ${Math.floor(score)}`, cx, cy - 20 * s);
  ctx.font = `${14 * s}px Arial, sans-serif`; ctx.fillStyle = 'rgba(255,255,255,0.7)';
  const mins = Math.floor(timeAlive / 60000), secs = Math.floor((timeAlive % 60000) / 1000);
  ctx.fillText(`Time: ${mins}:${secs.toString().padStart(2, '0')}`, cx, cy + 15 * s);
  const activeCount = stemVolumes.filter(v => v > 0.1).length;
  ctx.fillText(`Stems Active at End: ${activeCount}/${NUM_STEMS}`, cx, cy + 38 * s);
  // Phase reached
  const diff = getDifficulty();
  ctx.fillText(`Phase Reached: ${diff.phase.toUpperCase()}`, cx, cy + 58 * s);
  if (Math.floor(score) >= highScore && highScore > 0) {
    ctx.fillStyle = '#FFD700'; ctx.font = `bold ${16 * s}px Arial, sans-serif`;
    ctx.fillText('New High Score!', cx, cy + 85 * s);
  }
  const blink = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
  ctx.globalAlpha = blink; ctx.fillStyle = '#FFD700'; ctx.font = `bold ${16 * s}px Arial, sans-serif`;
  ctx.fillText('Click or Tap to Play Again', cx, cy + 115 * s); ctx.globalAlpha = 1;
}

// ============================================================
// GAME LOGIC
// ============================================================

function resetGame() {
  player.x = W / 2;
  player.y = H * 0.4;
  player.vx = 0; player.vy = 0;
  player.facing = 1; player.bounceAnim = 0; player.hairPhase = 0;
  clouds = []; particles = []; floatingTexts = []; trail = [];
  stemFlashes = []; ripples = [];
  score = 0; timeAlive = 0;
  comboTypes = new Set(); comboMultiplier = 1;
  shakeX = 0; shakeY = 0; shakeIntensity = 0;
  stemVolumes = new Array(NUM_STEMS).fill(0);
  stemTimers = new Array(NUM_STEMS).fill(0);
  for (let i = 0; i < NUM_STEMS; i++) { if (stemGains[i]) stemGains[i].gain.value = 0; }
  cloudSpawnTimer = 0;

  // Guaranteed landing cloud (extra wide for chill intro)
  clouds.push({
    x: player.x, y: player.y + 55 * SCALE,
    w: 140 * SCALE, h: 50 * SCALE, vx: 0,
    stemIndex: Math.floor(Math.random() * NUM_STEMS),
    glow: 0.5, pulsePhase: 0,
  });

  // Initial clouds - big and slow (chill phase)
  for (let i = 0; i < 7; i++) {
    const y = (CLOUD_MIN_Y + (i / 7) * (CLOUD_MAX_Y - CLOUD_MIN_Y)) * H;
    const x = W * 0.1 + Math.random() * W * 0.8;
    const stemIndex = Math.floor(Math.random() * NUM_STEMS);
    const w = (95 + Math.random() * 55) * SCALE; // bigger starting clouds
    const h = (40 + Math.random() * 15) * SCALE;
    const speed = (0.4 + Math.random() * 0.5) * SCALE;
    const dir = Math.random() < 0.5 ? 1 : -1;
    clouds.push({ x, y, w, h, vx: speed * dir, stemIndex, glow: 0, pulsePhase: Math.random() * Math.PI * 2 });
  }

  countdownTimer = 0; countdownNum = 3;
}

function updateCountdown(dt) {
  countdownTimer += dt;
  if (countdownTimer >= 1000) { countdownTimer -= 1000; countdownNum--; if (countdownNum < 0) gameState = 'playing'; }
}

function updateGame(dt) {
  timeAlive += dt;
  const diff = getDifficulty();

  // Input
  let moveDir = 0;
  if (keys['ArrowLeft'] || keys['KeyA'] || touchLeft) moveDir -= 1;
  if (keys['ArrowRight'] || keys['KeyD'] || touchRight) moveDir += 1;
  player.vx += moveDir * MOVE_ACCEL * SCALE;
  player.vx *= MOVE_FRICTION;
  if (moveDir !== 0) player.facing = moveDir;

  // Gravity from difficulty system
  const grav = diff.gravity * diff.dropMultiplier;
  player.vy += grav * SCALE;
  player.x += player.vx;
  player.y += player.vy;

  // Wrap horizontally
  if (player.x < -30 * SCALE) player.x = W + 30 * SCALE;
  if (player.x > W + 30 * SCALE) player.x = -30 * SCALE;

  // Trail
  if (Math.abs(player.vy) > 4 * SCALE) {
    trail.push({ x: player.x, y: player.y, alpha: 0.4, facing: player.facing });
    if (trail.length > 6) trail.shift();
  }
  for (let i = trail.length - 1; i >= 0; i--) {
    trail[i].alpha -= 0.03;
    if (trail[i].alpha <= 0) trail.splice(i, 1);
  }

  // Bounce anim decay
  player.bounceAnim *= 0.9;
  if (player.bounceAnim < 0.01) player.bounceAnim = 0;

  // Screen shake decay
  shakeIntensity *= 0.9;
  if (shakeIntensity > 0.1) {
    shakeX = (Math.random() - 0.5) * shakeIntensity * SCALE;
    shakeY = (Math.random() - 0.5) * shakeIntensity * SCALE;
  } else { shakeX = 0; shakeY = 0; shakeIntensity = 0; }

  // Cloud spawning - rate from difficulty
  cloudSpawnTimer += dt;
  if (cloudSpawnTimer > diff.spawnRate) {
    cloudSpawnTimer = 0;
    spawnCloud();
  }

  // Update clouds
  for (let i = clouds.length - 1; i >= 0; i--) {
    const c = clouds[i];
    c.x += c.vx;
    c.glow = Math.max(0, c.glow - 0.02);
    c.pulsePhase += 0.05;
    if (c.vx > 0 && c.x > W + c.w * 2) { clouds.splice(i, 1); continue; }
    if (c.vx < 0 && c.x < -c.w * 2) { clouds.splice(i, 1); continue; }

    // Collision
    if (player.vy > 0) {
      const px = player.x;
      const py = player.y + 27 * SCALE;
      const prevPy = py - player.vy;
      if (px > c.x - c.w * 0.45 && px < c.x + c.w * 0.45 &&
          py >= c.y - c.h * 0.3 && prevPy < c.y - c.h * 0.3 + player.vy + 5 * SCALE) {
        // Bounce!
        player.vy = BOUNCE_VEL * SCALE;
        player.y = c.y - c.h * 0.3 - 27 * SCALE;
        player.bounceAnim = 1;
        c.glow = 1;
        shakeIntensity = 4;

        // Ripple effect
        spawnRipple(c.x, c.y, STEM_DEFS[c.stemIndex].color);

        // Activate stem
        const wasActive = stemVolumes[c.stemIndex] > 0.1;
        activateStem(c.stemIndex);

        // Stem name flash (only on fresh activation)
        if (!wasActive) {
          spawnStemFlash(STEM_DEFS[c.stemIndex].name, STEM_DEFS[c.stemIndex].color, c.x, c.y);
        }

        // Score & combo
        comboTypes.add(c.stemIndex);
        let prevMultiplier = comboMultiplier;
        if (comboTypes.size >= NUM_STEMS) {
          comboMultiplier = 5;
          for (let j = 0; j < 30; j++) {
            if (particles.length >= MAX_PARTICLES) particles.shift();
            const angle = (j / 30) * Math.PI * 2;
            const speed = (4 + Math.random() * 6) * SCALE;
            particles.push({
              x: px, y: py, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
              life: 1, decay: 0.008, size: (4 + Math.random() * 4) * SCALE,
              color: STEM_DEFS[j % NUM_STEMS].color, type: 'fluff',
            });
          }
          shakeIntensity = 10;
          spawnFloatingText(px, py - 30 * SCALE, '5x ALL STEMS!', '#FFD700');
          comboTypes = new Set();
        } else if (comboTypes.size >= 3) {
          comboMultiplier = 2;
        } else if (comboTypes.size >= 2) {
          comboMultiplier = 1.5;
        } else {
          comboMultiplier = 1;
        }
        if (comboMultiplier > prevMultiplier && comboMultiplier < 5) {
          spawnFloatingText(px, py - 20 * SCALE, `${comboMultiplier}x`, '#FFD700');
        }
        const points = Math.floor(10 * comboMultiplier);
        score += points;
        spawnFloatingText(px + (Math.random() - 0.5) * 20 * SCALE, py - 10 * SCALE, `+${points}`, '#FFFFFF');
        spawnBounceParticles(px, c.y - c.h * 0.3, STEM_DEFS[c.stemIndex].color);
      }
    }
  }

  ensureReachableClouds();
  score += dt / 1000;
  updateStemVolumes(dt);
  updateEffects(dt);

  // Game over
  if (player.y > H + 100 * SCALE) {
    gameState = 'gameover';
    gameOverTime = Date.now();
    if (Math.floor(score) > highScore) {
      highScore = Math.floor(score);
      localStorage.setItem('cloudbounce_high', highScore.toString());
    }
  }
}

let gameOverTime = 0;

// ============================================================
// DRAW GAME
// ============================================================

function drawGame() {
  ctx.save();
  ctx.translate(shakeX, shakeY);
  drawBackground();

  const activeCount = stemVolumes.filter(v => v > 0.1).length;
  if (activeCount >= 3) {
    const intensity = (activeCount / NUM_STEMS) * 0.3;
    const bp = getBeatPulse();
    const edgeGrad = ctx.createRadialGradient(W / 2, H / 2, Math.min(W, H) * 0.3, W / 2, H / 2, Math.min(W, H) * 0.7);
    edgeGrad.addColorStop(0, 'rgba(200,100,255,0)');
    edgeGrad.addColorStop(1, `rgba(200,100,255,${intensity + bp * 0.1})`);
    ctx.fillStyle = edgeGrad; ctx.fillRect(0, 0, W, H);
  }

  if (player.y > H * 0.75 && gameState === 'playing') {
    const danger = (player.y - H * 0.75) / (H * 0.25);
    ctx.fillStyle = `rgba(0,0,0,${danger * 0.4})`; ctx.fillRect(0, 0, W, H);
    const vigGrad = ctx.createRadialGradient(W / 2, H / 2, Math.min(W, H) * 0.2, W / 2, H / 2, Math.min(W, H) * 0.6);
    vigGrad.addColorStop(0, 'rgba(255,0,0,0)');
    vigGrad.addColorStop(1, `rgba(255,0,0,${danger * 0.15})`);
    ctx.fillStyle = vigGrad; ctx.fillRect(0, 0, W, H);
  }

  clouds.forEach(c => drawCloud(c));
  drawEffects();

  // Trail afterimages
  trail.forEach(t => {
    ctx.globalAlpha = t.alpha * 0.5;
    const sf = player.facing, sb = player.bounceAnim;
    player.facing = t.facing; player.bounceAnim = 0;
    drawCharacter(t.x, t.y);
    player.facing = sf; player.bounceAnim = sb;
    ctx.globalAlpha = 1;
  });

  drawCharacter(player.x, player.y);
  if (gameState === 'playing' || gameState === 'gameover') drawHUD();
  ctx.restore();
}

// ============================================================
// MAIN LOOP
// ============================================================

let lastTime = 0;

function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = Math.min(timestamp - lastTime, 33);
  lastTime = timestamp;
  ctx.clearRect(0, 0, W, H);

  switch (gameState) {
    case 'title': drawTitleScreen(); break;
    case 'loading': drawLoading(); break;
    case 'countdown': updateCountdown(dt); drawGame(); drawCountdown(); break;
    case 'playing': updateGame(dt); drawGame(); break;
    case 'gameover':
      const timeSinceDeath = Date.now() - gameOverTime;
      if (timeSinceDeath < 4000) {
        for (let i = 0; i < NUM_STEMS; i++) {
          stemVolumes[i] = Math.max(0, stemVolumes[i] - dt / 4000);
          if (stemGains[i]) stemGains[i].gain.value = stemVolumes[i];
        }
      } else { updateStemVolumes(dt); }
      updateEffects(dt);
      drawGame(); drawGameOver();
      break;
  }
  requestAnimationFrame(gameLoop);
}

// ============================================================
// INPUT HANDLERS
// ============================================================

document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'ArrowDown') e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

async function handleStart() {
  if (gameState === 'title') {
    gameState = 'loading';
    await initAudio();
    resetGame();
    gameState = 'countdown';
  } else if (gameState === 'gameover') {
    if (audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
    resetGame();
    stems.forEach((s, i) => { stemGains[i].gain.value = 0; });
    gameState = 'countdown';
  }
}

canvas.addEventListener('click', handleStart);

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (gameState === 'title' || gameState === 'gameover') { handleStart(); return; }
  for (const touch of e.touches) { if (touch.clientX < window.innerWidth / 2) touchLeft = true; else touchRight = true; }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault(); touchLeft = false; touchRight = false;
  for (const touch of e.touches) { if (touch.clientX < window.innerWidth / 2) touchLeft = true; else touchRight = true; }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault(); touchLeft = false; touchRight = false;
  for (const touch of e.touches) { if (touch.clientX < window.innerWidth / 2) touchLeft = true; else touchRight = true; }
}, { passive: false });

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
